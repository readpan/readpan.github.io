{"meta":{"title":"Read Pan Blog","subtitle":null,"description":null,"author":"Read Pan","url":"https://readpan.github.io","root":"/"},"pages":[],"posts":[{"title":"UniRx - Unity响应式扩展","slug":"translate-unirx","date":"2019-11-21T08:11:21.000Z","updated":"2019-11-21T08:15:05.349Z","comments":true,"path":"2019/11/21/translate-unirx/","link":"","permalink":"https://readpan.github.io/2019/11/21/translate-unirx/","excerpt":"","text":"UniRx - Unity响应式扩展写在前面本文是翻译UniRx在GitHub中的README。 翻译的目的是为了让自己能够在看原文档的时候，真正理解其意。所以，有些地方使用Google的机器翻译。 UniRx是什么UniRx（Unity的响应式扩展）是.NET响应式扩展的重新实现。官方的响应式扩展很好，但是在Unity中无法工作，并且对iOS IL2CPP兼容性存在问题。本库修复了这些问题并且添加了一些特殊的Unity工具。支持平台PC / Mac / Android / iOS / WebGL / WindowsStore / etc和库。 为什么Rx？通常来讲，Unity中的网络操作需要使用WWW和Coroutine。出于以下（和其他）原因，对于异步操作，使用Coroutine并不是一种好习惯： 协程不能返回任何值，因为它的返回类型必须是IEnumerator。 协程不能处理异常，因为yield return语句不能用try-catch结构包围。 这种缺乏可组合性的操作导致操作紧密耦合，这通常会导致庞大的整体式IEnumerator。 Rx可以解决这种“异步坑”。 Rx是一个库，用于使用可观察的集合和LINQ样式的查询运算符来组成基于异步和基于事件的程序。 游戏循环（每次Update，OnCollisionEnter等），传感器数据（Kinect，Leap Motion，VR Input等）都是事件类型。 Rx将事件表示为反应性序列，这些事件既易于组合，又使用LINQ查询运算符支持基于时间的操作。 Unity通常是单线程的，但是UniRx促进连接，取消，访问GameObjects等的多线程。 UniRx帮助使用uGUI进行UI编程。 所有UI事件（单击，更改值等）都可以转换为UniRx事件流。 Unity从2017年开始通过C＃升级支持async / await，UniRx系列产品提供与Unity的更轻便，更强大的async / await集成。 请参见Cysharp / UniTask。 介绍很棒的Rx相关文章：The introduction to Reactive Programming you’ve been missing. 下面的代码实现了双击检测： 123456var clickStream = Observable.EveryUpdate() .Where(_ =&gt; Input.GetMouseButtonDown(0));clickStream.Buffer(clickStream.Throttle(TimeSpan.FromMilliseconds(250))) .Where(xs =&gt; xs.Count &gt;= 2) .Subscribe(xs =&gt; Debug.Log(\"DoubleClick Detected! Count:\" + xs.Count)); 这个例子展示了以下特性（仅在5行代码中！）： 以游戏循环（Update）作为一个事件流 可组合的事件流 自我合并流 易于处理基于时间的操作 网络操作 未完待续…","categories":[],"tags":[{"name":"UniRx","slug":"UniRx","permalink":"https://readpan.github.io/tags/UniRx/"},{"name":"Unity","slug":"Unity","permalink":"https://readpan.github.io/tags/Unity/"}]},{"title":"求职模拟器","slug":"mind-job-simulator","date":"2019-11-08T08:24:08.000Z","updated":"2019-11-08T08:29:57.381Z","comments":true,"path":"2019/11/08/mind-job-simulator/","link":"","permalink":"https://readpan.github.io/2019/11/08/mind-job-simulator/","excerpt":"","text":"","categories":[],"tags":[{"name":"mind","slug":"mind","permalink":"https://readpan.github.io/tags/mind/"}]},{"title":"StarUML3.1 For Mac Crack","slug":"soft-staruml","date":"2019-11-07T01:07:06.000Z","updated":"2019-11-19T03:13:25.551Z","comments":true,"path":"2019/11/07/soft-staruml/","link":"","permalink":"https://readpan.github.io/2019/11/07/soft-staruml/","excerpt":"","text":"破解前提 安装StarUML 3.1 安装nodejs 安装npm 安装asar1npm install asar -g 如果权限不够, 可以添加前缀sudo执行. 1sudo npm install asar -g 解压app.asar12cd /Applications/StarUML.app/Contents/Resources/asar extract app.asar app 替换代码替换下面脚本中的代码块 1/Applications/StarUML.app/Contents/Resources/app/src/engine/license-manager.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/** Copyright (c) 2013-2014 Minkyu Lee. All rights reserved.** NOTICE: All information contained herein is, and remains the* property of Minkyu Lee. The intellectual and technical concepts* contained herein are proprietary to Minkyu Lee and may be covered* by Republic of Korea and Foreign Patents, patents in process,* and are protected by trade secret or copyright law.* Dissemination of this information or reproduction of this material* is strictly forbidden unless prior written permission is obtained* from Minkyu Lee (niklaus.lee@gmail.com).**/const &#123;EventEmitter&#125; = require('events')const fs = require('fs')const path = require('path')const crypto = require('crypto')const UnregisteredDialog = require('../dialogs/unregistered-dialog')const SK = 'DF9B72CC966FBE3A46F99858C5AEE'// Check License When File Saveconst LICENSE_CHECK_PROBABILITY = 0.3var status = falsevar licenseInfo = null/** * Set Registration Status * This function is out of LicenseManager class for the security reason * (To disable changing License status by API) * @private * @param &#123;boolean&#125; newStat * @return &#123;string&#125; */function setStatus (licenseManager, newStat) &#123; if (status !== newStat) &#123; status = newStat licenseManager.emit('statusChanged', status) &#125;&#125;/** * @private */class LicenseManager extends EventEmitter &#123; constructor () &#123; super() this.projectManager = null &#125; /** * Get Registration Status * @return &#123;string&#125; */ getStatus () &#123; return status &#125; /** * Get License Infomation * @return &#123;Object&#125; */ getLicenseInfo () &#123; return licenseInfo &#125; findLicense () &#123; var licensePath = path.join(app.getUserPath(), '/license.key') if (!fs.existsSync(licensePath)) &#123; licensePath = path.join(app.getAppPath(), '../license.key') &#125; if (fs.existsSync(licensePath)) &#123; return licensePath &#125; else &#123; return null &#125; &#125; /** * Check license validity * * @return &#123;Promise&#125; */ validate () &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; // Local check var file = this.findLicense() if (!file) &#123; reject('License key not found') &#125; else &#123; var data = fs.readFileSync(file, 'utf8') licenseInfo = JSON.parse(data) resolve(licenseInfo) &#125; &#125; catch (err) &#123; reject(err) &#125; &#125;) &#125; checkLicenseValidity () &#123; this.validate().then(() =&gt; &#123; setStatus(this, true) &#125;, () =&gt; &#123; setStatus(this, false) UnregisteredDialog.showDialog() &#125;) &#125; /** * Check the license key in server and store it as license.key file in local * * @param &#123;string&#125; licenseKey */ register (licenseKey) &#123; return new Promise((resolve, reject) =&gt; &#123; var data = &#123; name: \"Reborn\", product: \"Reborn product\", licenseType: \"PS\", quantity: \"Reborn Quantity\", timestamp: \"1529049036\", licenseKey: \"It's Cracked!!\", crackedAuthor: \"Reborn\" &#125; var file = path.join(app.getUserPath(), '/license.key') fs.writeFileSync(file, JSON.stringify(data, 2)) licenseInfo = data setStatus(this, true) resolve(data) &#125;) &#125; htmlReady () &#123; this.projectManager.on('projectSaved', (filename, project) =&gt; &#123; var val = Math.floor(Math.random() * (1.0 / LICENSE_CHECK_PROBABILITY)) if (val === 0) &#123; this.checkLicenseValidity() &#125; &#125;) &#125; appReady () &#123; this.checkLicenseValidity() &#125;&#125;module.exports = LicenseManager 打包app12cd /Applications/StarUML.app/Contents/Resourcesasar pack app app.asar 至此，破解结束。 后续补充如果在打开app的时候, 遇到已损坏情况. 可以输入以下命令 1sudo spctl --master-disable","categories":[],"tags":[{"name":"Crack","slug":"Crack","permalink":"https://readpan.github.io/tags/Crack/"}]},{"title":"这个blog是如何建立的","slug":"how-to-create-this-blog","date":"2019-10-28T02:09:25.000Z","updated":"2019-10-31T08:01:29.202Z","comments":true,"path":"2019/10/28/how-to-create-this-blog/","link":"","permalink":"https://readpan.github.io/2019/10/28/how-to-create-this-blog/","excerpt":"","text":"使用hexo + github pages 建立此博客，下面我将详细描述在基于MacOS的系统环境下建站步骤。 安装Hexo是一个博客框架，基于nodejs运行。使用步骤如下： 安装nodejs 使用npm install -g hexo-cli命令安装hexo 如果在安装hexo过程中遇到问题，请查询官方文档 使用Hexo创建Hexo项目 创建一个空文件夹 打开终端并定位到该文件夹 执行下面命令 1234cd your_folder_directoryhexo init ./cd &lt;folder&gt;npm install 此时的博客已经建立好 更多细节内容可以查看官方文档 写作创建一篇文章在项目路径下打开终端，并键入 1hexo new \"hello\" 这样就会在项目目录./source/_post中创建相应的md文件，编辑这个文件即可进行写作。 使用Typora快速保存，插入本地图片如果使用Typora进行写作，可以进行如下设置，以快速保存图片到项目本地。 在Typora - 偏好设置 - 图像中，设置如下图 静态网站生成使用命令hexo g可以生成静态网站，生成后会存放在public文件夹下面。 可以使用hexo s开启本地服务器，进行本地测试。 部署到GitHub Pages可以根据官方文档，进行部署。","categories":[],"tags":[]}]}